import { Field } from "./Field";
import { FieldPosition } from "./FieldPosition";
import { Fields } from "./Fields";
export const getHeadersProxy = (fields) => {
    const headers = fieldsToHeaders(fields);
    return new Proxy(headers, {
        set(target, property, newValue) {
            if (newValue == null)
                return true;
            Reflect.set(target, property, newValue);
            const field = new Field({ name: property, values: headerValueToFieldValues(newValue) });
            fields.setField(field);
            return true;
        },
        defineProperty(target, property, attributes) {
            const { configurable, enumerable, writable, value } = attributes;
            if (configurable && enumerable && writable && value != null) {
                Reflect.defineProperty(target, property, attributes);
                const field = new Field({ name: property, values: headerValueToFieldValues(value) });
                fields.setField(field);
            }
            return true;
        },
        deleteProperty(target, property) {
            Reflect.deleteProperty(target, property);
            fields.removeField(property);
            return true;
        },
    });
};
export const headersToFields = (headers) => {
    return Fields.from(Object.entries(headers)
        .filter(([, value]) => value != null)
        .map(([key, value]) => ({ name: key, values: headerValueToFieldValues(value), kind: FieldPosition.HEADER })));
};
export const fieldsToHeaders = (fields) => {
    return fields
        .getByType(FieldPosition.HEADER)
        .reduce((headers, field) => ({ ...headers, [field.name]: field.values.join(",") }), {});
};
export const headerValueToFieldValues = (headerValue) => {
    if (headerValue == null)
        return undefined;
    return String(headerValue).split(",");
};
